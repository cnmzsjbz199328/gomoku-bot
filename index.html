<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>æ™ºèƒ½äº”å­æ£‹ 12x12</title>
  <style>
    body {
      font-family: 'Microsoft YaHei', Arial, sans-serif;
      text-align: center;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      margin: 0;
      padding: 20px;
      min-height: 100vh;
      color: white;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      padding: 20px;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    h1 {
      margin-bottom: 10px;
      font-size: 2.5em;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .game-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 10px;
    }

    .status {
      font-size: 1.2em;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    button {
      padding: 10px 20px;
      border: none;
      border-radius: 25px;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s ease;
      backdrop-filter: blur(5px);
    }

    button:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-2px);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .difficulty-selector {
      display: flex;
      gap: 5px;
      align-items: center;
    }

    .difficulty-btn {
      padding: 5px 15px;
      font-size: 12px;
    }

    .difficulty-btn.active {
      background: rgba(255, 255, 255, 0.4);
    }

    #board {
      display: grid;
      grid-template-columns: repeat(12, 35px);
      grid-template-rows: repeat(12, 35px);
      gap: 1px;
      margin: 20px auto;
      width: fit-content;
      background: #8B4513;
      padding: 10px;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .cell {
      width: 35px;
      height: 35px;
      background-color: #DEB887;
      border: 1px solid #8B4513;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }

    .cell:hover:not(.occupied) {
      background-color: #F4E4BC;
      transform: scale(1.1);
    }

    .cell.black::after {
      content: '';
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #444, #000);
      box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    .cell.white::after {
      content: '';
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #fff, #ddd);
      box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .cell.last-move {
      background-color: #FFD700 !important;
    }

    .cell.winning-stone::after {
      box-shadow: 0 0 15px #FFD700, 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    .game-stats {
      display: flex;
      justify-content: center;
      gap: 30px;
      margin-top: 20px;
      flex-wrap: wrap;
    }

    .stat {
      text-align: center;
    }

    .stat-value {
      font-size: 1.5em;
      font-weight: bold;
      color: #FFD700;
    }

    .thinking {
      font-style: italic;
      color: #FFD700;
    }

    @media (max-width: 600px) {
      #board {
        grid-template-columns: repeat(12, 30px);
        grid-template-rows: repeat(12, 30px);
      }
      
      .cell {
        width: 30px;
        height: 30px;
      }
      
      .cell.black::after,
      .cell.white::after {
        width: 24px;
        height: 24px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ¯ æ™ºèƒ½äº”å­æ£‹</h1>
    
    <div class="game-info">
      <div class="status" id="status">ä½ å…ˆæ‰‹ï¼šæ‰§é»‘å­</div>
      <div class="controls">
        <button onclick="newGame()">ğŸ® æ–°æ¸¸æˆ</button>
        <button onclick="undoMove()" id="undoBtn">â†¶ æ‚”æ£‹</button>
        <button onclick="getHint()" id="hintBtn">ğŸ’¡ æç¤º</button>
      </div>
    </div>

    <div class="difficulty-selector">
      <span>éš¾åº¦ï¼š</span>
      <button class="difficulty-btn active" onclick="setDifficulty('easy')">ç®€å•</button>
      <button class="difficulty-btn" onclick="setDifficulty('medium')">ä¸­ç­‰</button>
      <button class="difficulty-btn" onclick="setDifficulty('hard')">å›°éš¾</button>
    </div>

    <div id="board"></div>

    <div class="game-stats">
      <div class="stat">
        <div class="stat-value" id="playerWins">0</div>
        <div>ç©å®¶èƒœåˆ©</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="aiWins">0</div>
        <div>AIèƒœåˆ©</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="draws">0</div>
        <div>å¹³å±€</div>
      </div>
    </div>
  </div>

  <script>
    const BOARD_SIZE = 12;
    const EMPTY = 0;
    const BLACK = 1;
    const WHITE = 2;
    
    let board = [];
    let gameOver = false;
    let playerTurn = true;
    let moveHistory = [];
    let lastMove = null;
    let difficulty = 'medium';
    let thinking = false;
    
    // ç»Ÿè®¡æ•°æ®
    let stats = {
      playerWins: parseInt(localStorage.getItem('playerWins') || '0'),
      aiWins: parseInt(localStorage.getItem('aiWins') || '0'),
      draws: parseInt(localStorage.getItem('draws') || '0')
    };

    // è¯„ä¼°æƒé‡
    const WEIGHTS = {
      five: 1000000,
      four: 10000,
      three: 1000,
      two: 100,
      one: 10
    };

    // æ–¹å‘å‘é‡
    const DIRECTIONS = [
      [0, 1], [1, 0], [1, 1], [1, -1]
    ];

    function initGame() {
      board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(EMPTY));
      gameOver = false;
      playerTurn = true;
      moveHistory = [];
      lastMove = null;
      thinking = false;
      updateStatus('ä½ å…ˆæ‰‹ï¼šæ‰§é»‘å­');
      renderBoard();
      updateStats();
    }

    function renderBoard() {
      const boardDiv = document.getElementById('board');
      boardDiv.innerHTML = '';
      
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.row = i;
          cell.dataset.col = j;
          
          if (board[i][j] === BLACK) {
            cell.classList.add('black', 'occupied');
          } else if (board[i][j] === WHITE) {
            cell.classList.add('white', 'occupied');
          }
          
          if (lastMove && lastMove.row === i && lastMove.col === j) {
            cell.classList.add('last-move');
          }
          
          cell.addEventListener('click', handleCellClick);
          boardDiv.appendChild(cell);
        }
      }
      
      // æ›´æ–°æŒ‰é’®çŠ¶æ€
      document.getElementById('undoBtn').disabled = moveHistory.length === 0 || gameOver;
      document.getElementById('hintBtn').disabled = !playerTurn || gameOver || thinking;
    }

    function handleCellClick(e) {
      if (gameOver || !playerTurn || thinking) return;
      
      const row = parseInt(e.target.dataset.row);
      const col = parseInt(e.target.dataset.col);
      
      if (board[row][col] !== EMPTY) return;
      
      makeMove(row, col, BLACK);
      
      if (checkWin(row, col, BLACK)) {
        endGame('ğŸ‰ æ­å–œä½ è·èƒœï¼');
        stats.playerWins++;
        saveStats();
        return;
      }
      
      if (isBoardFull()) {
        endGame('ğŸ¤ å¹³å±€ï¼');
        stats.draws++;
        saveStats();
        return;
      }
      
      playerTurn = false;
      updateStatus('AIæ€è€ƒä¸­...');
      thinking = true;
      renderBoard();
      
      setTimeout(() => {
        aiMove();
      }, 500);
    }

    function makeMove(row, col, player) {
      board[row][col] = player;
      moveHistory.push({ row, col, player });
      lastMove = { row, col };
    }

    function aiMove() {
      if (gameOver) return;
      
      const move = getBestMove();
      makeMove(move.row, move.col, WHITE);
      
      thinking = false;
      renderBoard();
      
      if (checkWin(move.row, move.col, WHITE)) {
        endGame('ğŸ¤– AIè·èƒœï¼');
        stats.aiWins++;
        saveStats();
        return;
      }
      
      if (isBoardFull()) {
        endGame('ğŸ¤ å¹³å±€ï¼');
        stats.draws++;
        saveStats();
        return;
      }
      
      playerTurn = true;
      updateStatus('è½®åˆ°ä½ äº†ï¼šæ‰§é»‘å­');
    }

    function getBestMove() {
      // æ ¹æ®éš¾åº¦é€‰æ‹©ä¸åŒçš„æœç´¢æ·±åº¦
      let depth;
      switch (difficulty) {
        case 'easy': depth = 1; break;
        case 'medium': depth = 2; break;
        case 'hard': depth = 3; break;
      }
      
      const moves = generateMoves();
      let bestMove = moves[0];
      let bestScore = -Infinity;
      
      for (const move of moves) {
        board[move.row][move.col] = WHITE;
        const score = minimax(depth - 1, -Infinity, Infinity, false);
        board[move.row][move.col] = EMPTY;
        
        if (score > bestScore) {
          bestScore = score;
          bestMove = move;
        }
      }
      
      return bestMove;
    }

    function minimax(depth, alpha, beta, isMaximizing) {
      if (depth === 0) {
        return evaluateBoard();
      }
      
      const moves = generateMoves();
      
      if (isMaximizing) {
        let maxScore = -Infinity;
        for (const move of moves) {
          board[move.row][move.col] = WHITE;
          const score = minimax(depth - 1, alpha, beta, false);
          board[move.row][move.col] = EMPTY;
          maxScore = Math.max(maxScore, score);
          alpha = Math.max(alpha, score);
          if (beta <= alpha) break;
        }
        return maxScore;
      } else {
        let minScore = Infinity;
        for (const move of moves) {
          board[move.row][move.col] = BLACK;
          const score = minimax(depth - 1, alpha, beta, true);
          board[move.row][move.col] = EMPTY;
          minScore = Math.min(minScore, score);
          beta = Math.min(beta, score);
          if (beta <= alpha) break;
        }
        return minScore;
      }
    }

    function generateMoves() {
      const moves = [];
      const occupied = new Set();
      
      // æ”¶é›†æ‰€æœ‰å·²å ç”¨çš„ä½ç½®
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          if (board[i][j] !== EMPTY) {
            occupied.add(`${i},${j}`);
          }
        }
      }
      
      // å¦‚æœæ£‹ç›˜ä¸ºç©ºï¼Œè¿”å›ä¸­å¿ƒä½ç½®
      if (occupied.size === 0) {
        return [{ row: Math.floor(BOARD_SIZE / 2), col: Math.floor(BOARD_SIZE / 2) }];
      }
      
      // ç”Ÿæˆå€™é€‰ä½ç½®ï¼ˆå·²å ç”¨ä½ç½®å‘¨å›´2æ ¼å†…çš„ç©ºä½ï¼‰
      const candidates = new Set();
      for (const pos of occupied) {
        const [r, c] = pos.split(',').map(Number);
        for (let dr = -2; dr <= 2; dr++) {
          for (let dc = -2; dc <= 2; dc++) {
            const nr = r + dr;
            const nc = c + dc;
            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && 
                board[nr][nc] === EMPTY) {
              candidates.add(`${nr},${nc}`);
            }
          }
        }
      }
      
      // è½¬æ¢ä¸ºç§»åŠ¨æ•°ç»„å¹¶æŒ‰è¯„ä¼°åˆ†æ•°æ’åº
      for (const pos of candidates) {
        const [r, c] = pos.split(',').map(Number);
        moves.push({ row: r, col: c });
      }
      
      // æŒ‰ä½ç½®è¯„ä¼°åˆ†æ•°æ’åºï¼Œä¼˜å…ˆè€ƒè™‘æ›´æœ‰å¸Œæœ›çš„ä½ç½®
      moves.sort((a, b) => {
        return evaluatePosition(b.row, b.col) - evaluatePosition(a.row, a.col);
      });
      
      return moves.slice(0, Math.min(20, moves.length)); // é™åˆ¶å€™é€‰æ•°é‡
    }

    function evaluateBoard() {
      let score = 0;
      
      // è¯„ä¼°æ‰€æœ‰è¡Œã€åˆ—ã€å¯¹è§’çº¿
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          if (board[i][j] !== EMPTY) {
            for (const [dx, dy] of DIRECTIONS) {
              score += evaluateLine(i, j, dx, dy, board[i][j]);
            }
          }
        }
      }
      
      return score;
    }

    function evaluatePosition(row, col) {
      let score = 0;
      
      // ä¸´æ—¶æ”¾ç½®æ£‹å­è¿›è¡Œè¯„ä¼°
      board[row][col] = WHITE;
      score += evaluatePlayerLines(row, col, WHITE) * 1.2;
      board[row][col] = EMPTY;
      
      board[row][col] = BLACK;
      score += evaluatePlayerLines(row, col, BLACK) * 1.0;
      board[row][col] = EMPTY;
      
      return score;
    }

    function evaluatePlayerLines(row, col, player) {
      let score = 0;
      
      for (const [dx, dy] of DIRECTIONS) {
        const lineInfo = getLineInfo(row, col, dx, dy, player);
        score += getLineScore(lineInfo);
      }
      
      return score;
    }

    function evaluateLine(row, col, dx, dy, player) {
      const lineInfo = getLineInfo(row, col, dx, dy, player);
      const score = getLineScore(lineInfo);
      return player === WHITE ? score : -score;
    }

    function getLineInfo(row, col, dx, dy, player) {
      let count = 1;
      let openEnds = 0;
      
      // æ­£æ–¹å‘
      let r = row + dx;
      let c = col + dy;
      while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {
        count++;
        r += dx;
        c += dy;
      }
      if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === EMPTY) {
        openEnds++;
      }
      
      // è´Ÿæ–¹å‘
      r = row - dx;
      c = col - dy;
      while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {
        count++;
        r -= dx;
        c -= dy;
      }
      if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === EMPTY) {
        openEnds++;
      }
      
      return { count, openEnds };
    }

    function getLineScore(lineInfo) {
      const { count, openEnds } = lineInfo;
      
      if (count >= 5) return WEIGHTS.five;
      if (count === 4) {
        if (openEnds === 2) return WEIGHTS.four;
        if (openEnds === 1) return WEIGHTS.four * 0.1;
      }
      if (count === 3) {
        if (openEnds === 2) return WEIGHTS.three;
        if (openEnds === 1) return WEIGHTS.three * 0.1;
      }
      if (count === 2) {
        if (openEnds === 2) return WEIGHTS.two;
        if (openEnds === 1) return WEIGHTS.two * 0.1;
      }
      if (count === 1 && openEnds > 0) return WEIGHTS.one;
      
      return 0;
    }

    function checkWin(row, col, player) {
      for (const [dx, dy] of DIRECTIONS) {
        let count = 1;
        
        // æ­£æ–¹å‘
        let r = row + dx;
        let c = col + dy;
        while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {
          count++;
          r += dx;
          c += dy;
        }
        
        // è´Ÿæ–¹å‘
        r = row - dx;
        c = col - dy;
        while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {
          count++;
          r -= dx;
          c -= dy;
        }
        
        if (count >= 5) {
          highlightWinningLine(row, col, dx, dy, player);
          return true;
        }
      }
      return false;
    }

    function highlightWinningLine(row, col, dx, dy, player) {
      const winningCells = [{row, col}];
      
      // æ­£æ–¹å‘
      let r = row + dx;
      let c = col + dy;
      while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {
        winningCells.push({row: r, col: c});
        r += dx;
        c += dy;
      }
      
      // è´Ÿæ–¹å‘
      r = row - dx;
      c = col - dy;
      while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === player) {
        winningCells.push({row: r, col: c});
        r -= dx;
        c -= dy;
      }
      
      // é«˜äº®è·èƒœçš„æ£‹å­
      setTimeout(() => {
        winningCells.forEach(cell => {
          const cellElement = document.querySelector(`[data-row="${cell.row}"][data-col="${cell.col}"]`);
          if (cellElement) {
            cellElement.classList.add('winning-stone');
          }
        });
      }, 100);
    }

    function isBoardFull() {
      for (let i = 0; i < BOARD_SIZE; i++) {
        for (let j = 0; j < BOARD_SIZE; j++) {
          if (board[i][j] === EMPTY) return false;
        }
      }
      return true;
    }

    function endGame(message) {
      gameOver = true;
      updateStatus(message);
      updateStats();
    }

    function updateStatus(message) {
      document.getElementById('status').textContent = message;
    }

    function newGame() {
      initGame();
    }

    function undoMove() {
      if (moveHistory.length === 0 || gameOver) return;
      
      // æ’¤é”€AIçš„ç§»åŠ¨
      if (moveHistory.length > 0) {
        const lastMove = moveHistory.pop();
        board[lastMove.row][lastMove.col] = EMPTY;
      }
      
      // æ’¤é”€ç©å®¶çš„ç§»åŠ¨
      if (moveHistory.length > 0) {
        const lastMove = moveHistory.pop();
        board[lastMove.row][lastMove.col] = EMPTY;
      }
      
      // æ›´æ–°æœ€åä¸€æ­¥
      lastMove = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;
      
      playerTurn = true;
      thinking = false;
      updateStatus('è½®åˆ°ä½ äº†ï¼šæ‰§é»‘å­');
      renderBoard();
    }

    function getHint() {
      if (!playerTurn || gameOver || thinking) return;
      
      thinking = true;
      updateStatus('åˆ†ææœ€ä½³ä½ç½®...');
      renderBoard();
      
      setTimeout(() => {
        const move = getBestMove();
        const cell = document.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
        if (cell) {
          cell.style.background = '#FFD700';
          cell.style.transform = 'scale(1.2)';
          setTimeout(() => {
            cell.style.background = '';
            cell.style.transform = '';
          }, 2000);
        }
        
        thinking = false;
        updateStatus('å»ºè®®ä½ç½®å·²æ ‡è®°ï¼ˆé‡‘è‰²é—ªçƒï¼‰');
        renderBoard();
      }, 800);
    }

    function setDifficulty(level) {
      difficulty = level;
      
      // æ›´æ–°æŒ‰é’®çŠ¶æ€
      document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      event.target.classList.add('active');
      
      // å¦‚æœæ¸¸æˆè¿›è¡Œä¸­ï¼Œç»™å‡ºæç¤º
      if (moveHistory.length > 0) {
        updateStatus(`éš¾åº¦å·²è°ƒæ•´ä¸º${level === 'easy' ? 'ç®€å•' : level === 'medium' ? 'ä¸­ç­‰' : 'å›°éš¾'}`);
      }
    }

    function updateStats() {
      document.getElementById('playerWins').textContent = stats.playerWins;
      document.getElementById('aiWins').textContent = stats.aiWins;
      document.getElementById('draws').textContent = stats.draws;
    }

    function saveStats() {
      localStorage.setItem('playerWins', stats.playerWins.toString());
      localStorage.setItem('aiWins', stats.aiWins.toString());
      localStorage.setItem('draws', stats.draws.toString());
      updateStats();
    }

    // åˆå§‹åŒ–æ¸¸æˆ
    initGame();
  </script>
</body>
</html>